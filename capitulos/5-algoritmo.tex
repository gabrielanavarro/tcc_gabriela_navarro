\chapter{Proposta de Algoritmo}
\label{algorithm-proposition}

Neste capítulo será apresentado o algoritmo que este trabalho visa propor, detalhes de seu funcionamento e suas vantagens.

\section{Motivação}
\label{motivation}

A evolução no campo da criptografia é constante e há sempre novas propostas de algoritmos que focam em solucionar um obstáculo imposto por possíveis atacantes e seus métodos para se obter informações sigilosas.

O algoritmo proposto neste trabalho visa diminuir as possibilidades de análises de frequência de um texto cifrado. É uma nova modalidade na produção de texto cifrado utilizando cifra de fluxo. 


\section{Funcionamento}
\label{functioning}

O algoritmo de cifração terá como entrada um texto em claro e uma sequência de números pseudo-aleatórios e terá como objetivo produzir um texto cifrado onde as frequências de ocorrência dos valores de \textit{bytes} cifrados seja totalmente balanceada.

O mecanismo utilizado para este balanceamento será produzir o texto cifrado em “rodadas” de 256 \textit{bytes} em que cada valor de \textit{byte} cifrado só aparece uma vez por rodada. Isto é, os 256  \textit{bytes} cifrados de cada rodada são distintos, porém a ordem em que aparecem em cada rodada é aleatória (ou melhor dizendo, pseudo-aleatória).

Para se garantir que nenhum valor de \textit{byte} cifrado se repita em uma rodada utiliza-se uma tabela de 256 posições. No início da rodada a tabela tem todas a suas 256 posições marcadas como não ocupadas. Para cada \textit{byte} de texto em claro que se deseja cifrar será feito um ou-exclusivo com o valor correspondente fornecido pelo gerador de números aleatórios resultando no \textit{byte} pré-cifrado. Tendo-se obtido o \textit{byte} pré-cifrado verifica-se se este valor já está ocupado na tabela. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{figuras/tabela.eps}
	\caption{Tabela de \textit{byte} para uso do algoritmo}
\end{figure}

Caso o valor do \textit{byte} pré-cifrado obtido corresponda a uma posição já ocupada na tabela, este valor não será aceito como \textit{byte} cifrado e o próximo valor da sequência pseudo-aleatória será utilizado para tentar novamente a cifração do \textit{byte} em claro. Este procedimento será repetido até que o valor pré-cifrado obtido corresponda a uma posição não ocupada na tabela, quando então este valor será aceito como o \textit{byte} cifrado (correspondente ao byte de texto em claro que está sendo processado pelo cifrador). O número de valores da sequência pseudo-aleatória não utilizados será contabilizado em uma variável j. 

Caso o valor do \textit{byte} pré-cifrado obtido corresponda a uma posição não ocupada na tabela, este valor será aceito como \textit{byte} cifrado, a posição correspondente na tabela será marcada como ocupada, e a variável j será reinicializada com o valor 0.

Aqui se introduz o problema de como enviar ao decifrador as seguintes informações:

\begin{enumerate}
	\item Que houve um conflito na cifração ( quando o mesmo ocorrer)
	\item Em ocorrendo o conflito, qual o número de valores na sequência pseudo-aleatória deverão ser desprezados na decifração.
\end{enumerate}

Para informar ao decifrador que houve um conflito na cifração propomos a utilização de um valor de \textit{byte} entre 0 e 255 chamado de \textbf{sinal}. Este valor será enviado pelo cifrador como parte da sequência de \textit{bytes} cifrados indicando ao decifrador que o \textit{byte} seguinte na sequência de \textit{bytes} cifrados corresponderá ao número de valores da sequência produzida pelo gerador pseudo-aleatório que deverão ser desprezados.  Após o envio do \textit{byte} de sinal, o cifrador  enviará o valor da variável j (também cifrado), e finalmente enviará o \textit{byte} cifrado.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{figuras/funcionamento.eps}
	\caption{Esquema do algoritmo de cifração}
\end{figure}

O processo de cifração, que pode ser visto no pseudo-código na figura \ref{pseudo-codigo}, segue os seguintes caminhos:

\begin{figure}[h]
	\centering
	\includegraphics[scale=1]{figuras/pseudocondigo.eps}
	\caption{Pseudo código do algoritmo de cifração}
	\label{pseudo-codigo}
\end{figure}

O caminho ideal é o que o resultado da operação ou-exclusivo entre o \textit{byte} do texto em claro e o número aleatório correpondente sempre corresponda a uma posição livre na tabela de balanceamento.

Caso se detecte um conflito de resultados na tabela de balanceamento, é enviado o \textit{byte} de sinal para o receptor da mensagem, pois com isso o receptor saberá que o próximo valor recebido será a quantidade de números pseudo-aleatórios que deverão ser descartados da sequência. 

Então o algoritmo vai executar o comando de descartar os números pseudo-aleatórios, até que se encontre um resultado em uma posição que esteja livre na tabela de balanceamento. 

Ao encontrar essa posição livre, o algoritmo (no lado da cifração) enviará o byte de sinal (sem cifrar) e em seguida enviará o resultado do ou-exclusivo entre \textbf{j} (quantidade de números descartados) e S$_{old}$. Então o valor de \textbf{j} é novamente reinicializado como 0.

Quando a tabela for totalmente concluída, a rodada termina e o processo se inicia de novo com uma nova rodada, reinicializando-se a tabela (todas as suas posições são marcadas como desocupadas). Esse processo termina quando os \textit{bytes} do texto em claro forem todos cifrados. A cada rodada o \textit{byte} de sinal terá um valor diferente. Escolhemos o primeiro \textit{byte} da sequência de números pseudo-aleatórios da rodada como o \textit{byte} de sinal. Este valor será também o último valor de \textit{byte} cifrado a ser enviado na rodada.

Quando terminarem os \textit{bytes} de texto em claro a serem cifrados, o cifrador envia novamente o valor do \textit{byte} de sinal da última rodada, indicando ao decifrador que o processo de cifração/decifração terminou.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{figuras/metodo_de_decifra.eps}
	\caption{Esquema do algoritmo de decifração}
\end{figure}

Podemos observar o processo de decifração na figura \ref{pseudo-codigo-decifrar}. Neste não é necessário se utilizar a tabela de balanceamento. Para se realizar a decifração é necessário que o decifrador tenha a capacidade de produzir a mesma sequência de números aleatórios que o cifrador. Isto implica que ele deve ter a mesma chave que foi utilizada no processo de cifrar.


\begin{figure}[h]
	\centering
	\includegraphics[scale=1]{figuras/funcionamento_Decifra.eps}
	\caption{Pseudo código do algoritmo de decifração}
	\label{pseudo-codigo-decifrar}
\end{figure}

No início de cada rodada na decifração, o primeiro \textit{byte} da sequência aleatória é separado como o \textit{byte} de sinal. Os valores pseudo-aleatórios seguintes serão usados no processo de decifração. O primeiro passo no processo de decifração é comparar o \textit{byte} cifrado recebido com o valor de sinal utilizado na rodada. 

Se o valor do \textit{byte} cifrado for diferente do valor do sinal utilizado na rodada, realiza-se a operação ou-exclusivo entre o \textit{byte} cifrado e o valor fornecido pelo gerador pseudo-aleatório, obtendo-se assim o \textit{byte} de texto em claro correspondente.

Se o valor do \textit{byte} cifrado for igual ao \textit{byte} de sinal utilizado na rodada, isso quer dizer que o próximo \textit{byte} do texto cifrado conterá o valor da variável \textbf{j} enviado pelo cifrador, que indica quantos números aleatórios devem ser descartados para o processo de decifração. Ao se descartar esses números, realiza-se a decifração do \textit{byte} cifrado e o processo de decifração volta ao curso normal de execução.

Após cada decifração o valor de \textbf{d} é incrementado. A variável \textbf{d} é responsável para determinar quando a rodada em questão finalizou. Quando o contador \textbf{d} for igual a 255, uma nova rodada se inicia e então o próximo valor da sequência de números aleatórios é separado como o novo \textit{byte} de sinal para a próxima rodada e a variável d é reinicializada com valor 0.

Para definir se o processo de decifração terminou, o decifrador testa se o primeiro \textit{byte} cifrado da rodada seguinte recebido é igual ao \textit{byte} de sinal da rodada anterior. Se for igual isto significa que a decifração terminou. Se não for igual, tem-se uma nova rodada.

\section{Vantagens}

A maior vantagem desse algoritmo é a equalização das frequências de ocorrência de cada valor de texto cifrado enviado. Excluindo-se os valores dos bytes de sinal e os valores dos números de sequência pseudo-aleatórios a serem desprezados na decifração, a frequência de cada valor possivel dos \textit{bytes} de texto cifrado será idêntica. Isto é, o algoritmo produz um texto cifrado perfeitamente balanceado.

Outra vantagem do algoritmo de balanceamento de frequência proposto é que ele é totalmente genérico.  Isto é, ele funciona com qualquer gerador de números pseudo-aleatórios e algoritmos de cifra de fluxo, tais como: A5/1, A5/2, E0, RC4, Blum Blum Shub, Blum Micali, etc.